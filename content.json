{"meta":{"title":"JJONGLOG","subtitle":"PROGRAMMING&PAINTING","description":null,"author":"jjong","url":"https://hjjjong0811.github.io"},"pages":[{"title":"Archives","date":"2018-09-05T07:44:05.169Z","updated":"2018-09-05T07:44:05.169Z","comments":true,"path":"archives.html","permalink":"https://hjjjong0811.github.io/archives.html","excerpt":"","text":""},{"title":"About","date":"2018-09-05T10:31:52.082Z","updated":"2018-09-05T10:31:52.082Z","comments":true,"path":"about.html","permalink":"https://hjjjong0811.github.io/about.html","excerpt":"","text":"JJONGLOG, PROGRAMMING &amp; PAINTING 프로그래밍을 공부하다보면 블로거분들의 도움을 많이 받는다. 알고 있는 지식들을 정리해서 올려주시고, 여쭤보면 댓글도 달아주신다. 도움을 받으며 나도 나중에 지식이 많아지면 내가 알고 있는 것들을 공유해야지 라고 생각해왔는데 대학 4학년이 되어서도 늘은 거라고는 구글링 뿐! 그래서 그냥 공부 목적의 블로그를 시작합니다! 공부 외에도 일상과 취미 관련한 내용을 올릴 예정입니다. 그림그리는 것과 뭔가 만드는 걸 좋아합니다! 만약 보시던 중 잘못된 내용이 있다면 덧글로 자유롭게 피드백주시면 감사하겠습니다"},{"title":"All tags","date":"2018-09-04T18:26:09.932Z","updated":"2018-09-04T18:26:09.932Z","comments":true,"path":"tags/index.html","permalink":"https://hjjjong0811.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ 가상함수에 대해서","slug":"programming/180913_CPP가상함수","date":"2018-09-13T06:06:00.000Z","updated":"2018-09-13T06:19:33.372Z","comments":true,"path":"2018/09/13/programming/180913_CPP가상함수/","link":"","permalink":"https://hjjjong0811.github.io/2018/09/13/programming/180913_CPP가상함수/","excerpt":"","text":"그동안 상속의 개념을 쓰면서도 다형성이 어떻게 지원되는지 그런 부분에 대해서는 조금 얕게(?) 생각했습니다. 컴파일러가 알아서 잘 해주겠거니~ 하는 마음 ㅎㅎ. 조금더 자세히 알아두면 좋을 것 같아 정리해봅니다! 내용은 가상함수가 무엇인지, 왜 쓰는지, 어떻게 동작하는지 에 대해서 쓸 예정입니다. 가상함수란C++에서 상속을 이용한다면, 상속받아야 하는 함수에는 virtual 키워드를 붙여야합니다. virtual 없이 override 하는 경우에는 기본 클래스 포인터로 override한 함수를 호출할 수 없습니다. 가상함수를 쓰지 않으면?코드를 먼저 보는 게 빠르겠죠 1234567891011121314151617class Animal&#123;public: void eat() &#123;cout &lt;&lt; \"냠\" &lt;&lt; endl;&#125;&#125;;class Cat:public Animal&#123;public: void eat() &#123;cout &lt;&lt; \"냥\" &lt;&lt; endl;&#125; //기본클래스의 함수를 덮어쓰려 합니다.&#125;;//----------------------int main()&#123; Animal *pAnimal; Cat cat; pAnimal = &amp;cat; pAnimal-&gt;eat(); //\"냠\" return 0;&#125; Cat의 함수를 호출하려 했으나 기본클래스인 Animal의 함수가 호출됩니다. 왜 이러는 걸까요? 컴파일러는 포인터의 타입으로 판단하기 때문입니다. 판단! 그렇죠. 컴파일러는 작성한 코드를 보고, 어떤 함수를 실행시킬지 매치시켜서 어셈블리 코드로 변환하겠지요. 그런데 포인터의 타입이 Animal 이라면? Animal 의 함수가 실행되게끔 만들겠지요? C# 에서는 문제없이 됐는걸요! 그건 어떻게 동작되는 거에요? 하는 궁금증이 생깁니다. 추측으로는 객체마다 Type에 대한 정보를 따로 담아두고 기본클래스 함수호출시 실제 타입이 어떤지 확인하는 식이 아닐까 생각하는데요. 그건 잠시 미뤄두겠습니다. 가상함수를 적용하면?그렇다면 가상함수를 적용하려면 어떻게 해야할까요? 간단하게 virtual 키워드만 붙이면 해결입니다! 12345678910111213141516171819class Animal&#123;public: virtual ~Animal()&#123;&#125; //가상 소멸자 -&gt; 아래에서 설명 virtual void eat(); //가상함수입니다&#125;class Cat:public Animal&#123;public: ~Cat()&#123;&#125; void eat() override; //가상함수를 override 합니다&#125;//----------------------int main()&#123; Animal *pAnimal; Cat cat; pAnimal = &amp;cat; pAnimal-&gt;eat(); //\"냥\" return 0;&#125; virtual 을 이용했더니 제대로 Cat 의 함수가 호출됩니다! 정리하자면, 가상함수를 쓰는 이유는 “다형성을 지원할 수 있다” 겠네요 가상함수동작방식가상함수가 어떤 것이고, 왜 써야하는지 대강 알겠어요. 그런데 virtual 키워드만 붙이면 기본 클래스의 포인터를 보고도 파생 클래스를 찾아준다니, 어떻게 그게 되는거죠? 컴파일할 때 Animal(기본 클래스) 의 포인터 타입으로 함수를 호출한다면 Animal 의 함수를 호출하게끔 바인드하겠지요. 하지만 Animal(기본 클래스) 의 함수에 virtual 키워드가 붙어있으면 인스턴스의 타입에 따라 함수를 바인드합니다. 그럼 인스턴스의 타입은 어떻게 알고, 바인드는 어떻게 하는 걸까요. 그건 가상함수 테이블을 이용해서 이뤄집니다. 가상함수테이블가상함수테이블은 파생 클래스마다 생성이 됩니다. 기본 클래스의 virtual 함수를 override한 함수가 어디있는지 저장해놓는 테이블입니다. 파생 클래스 인스턴스들은 가상함수테이블을 가르키는 가상함수포인터를 가지고있습니다. 그러니까 인스턴스의 가상함수포인터를 통해서 가상함수 테이블을 참조하고, 해당하는 함수의 주소를 찾아서 호출하는 방식이지요! 디버깅 툴로 확인하기 #1어떤 구조로 들어있는 건지 확인해볼까요? Visual Studio는 좋은 툴이에요. 디버깅을 해봅시다 1234567891011121314151617181920212223242526272829303132333435class Animal &#123;public: virtual ~Animal() &#123; &#125; //가상소멸자 virtual void eat() &#123; //가상함수 cout &lt;&lt; \"냠\" &lt;&lt; endl; &#125;&#125;;class Cat :public Animal &#123;public: ~Cat() &#123;&#125; void eat() &#123; //가상함수를 override 합니다 cout &lt;&lt; \"냥\" &lt;&lt; endl; &#125;&#125;;class Dog :public Animal &#123; //Cat과의 차이를 보기 위해 추가했습니다public: ~Dog() &#123;&#125; void eat() &#123; //가상함수를 override 합니다 cout &lt;&lt; \"멍\" &lt;&lt; endl; &#125;&#125;;//----------------------int main() &#123; Animal *pAnimal1, *pAnimal2; Cat cat; Dog dog; pAnimal1 = &amp;cat; pAnimal2 = &amp;dog; pAnimal1-&gt;eat(); //\"냥\" pAnimal2-&gt;eat(); //\"멍\" return 0;&#125; Cat클래스의 인스턴스에 __vfptr(가상 함수 포인터)이라는게 눈에 띄네요. 값을 보니 Cat::vftable[3]() 이라는게 있는데 이게 virtual funtion table(가상함수테이블) 인가봅니다. 안에는 virtual 키워드가 붙어있던 함수들이 있군요. 소멸자와 eat() 함수가 들어있습니다. 디버깅 툴로 확인하기 #2가상함수를 쓰지 않는다면 구조는 아래와 같습니다 단순하네요. 가상함수를 썼을 때는 인스턴스마다 __vfptr(가상 함수 포인터)가 들어갔고, 가상 함수 포인터가 가르키는 곳에는 가상함수테이블이 있었는데, 얘는 밋밋해요. 가상함수는 다형성을 지원하도록 해주는 정말 좋은 아이지만, 그렇다고 필요하지 않은 곳에 사용하면 안됩니다. 인스턴스마다 가상 함수 포인터(4bytes)가 들어간다면 크기가 커질테니까요. 가상소멸자Animal(기본 클래스)의 포인터를 사용해서 함수를 호출하면 Cat(파생 클래스)의 함수가 호출되지 않는다고 했습니다. 그러면 소멸자의 경우에는 어떨까요? 소멸자도 마찬가지입니다. Animal(기본 클래스)의 포인터 타입을 보고 소멸자를 바인드하기 때문에 Cat(파생 클래스)의 소멸자는 호출되지 않습니다. 파생 클래스의 소멸자가 호출되지 않으면 파생 클래스에서 할당된 메모리는 어떻게 되는거죠? 새는거죠. 어떤 클래스를 기본 클래스로 사용하고 싶다면 소멸자에는 꼭 virtual 을 붙여줍시다! 순수 가상 소멸자순수 가상 소멸자라는 얘기를 들었어요. 가상 소멸자는 이제 알겠는데, 왜 순수가 붙는거죠? :o 순수함수와 순수가상함수순수함수는 파라미터에 의해서만 함수의 동작이 결정되는 함수입니다. 같은 파라미터를 넣었다면 같은 값이 리턴되죠. 그 외에 Side Effect가 없어야 합니다. 순수가상함수는 순수함수와 다릅니다. 그냥 의미가 달라요. 순수가상함수는 구현이 없는 가상함수입니다. 순수가상함수를 포함하면 해당 클래스는 추상 클래스가 되지요. 1virtual void eat() = 0; //0을 대입하면 순수가상함수 순수가상소멸자그렇다면 순수가상소멸자는 왜 사용하는 걸까요? JAVA같은 경우엔 추상 클래스로 만드려면 abstract 키워드를 이용했습니다. C++에서 추상 클래스를 만드려면 순수 가상 함수를 포함하면 해당 클래스는 추상클래스가 됩니다. 하지만 마땅히 가질만한 순수 가상 함수가 없는 경우에는 어떻게 추상 클래스로 만들 수 있을까요? 그 방법이 순수가상소멸자입니다. 소멸자를 순수가상함수로 만듦으로서 추상클래스로 만드는 겁니다. 12//.h 선언virtual ~Animal() = 0; 아, 그런데 참 재밌는게 파생 클래스의 소멸자가 호출된 후에 기본 클래스의 소멸자도 호출됩니다. 그러니까 순수가상소멸자로 구현없이 남겨두면 기본 클래스의 소멸자를 찾을 수 없다는 오류메시지가 마구마구 뜬다는 말이죠. 아무것도 안하는 순수가상소멸자더라도 선언과 정의는 빼먹지 말아야합니다 12//.cpp 정의Animal::~Animal()&#123;&#125; 넵 이렇게 가상함수에 대해 정리해봤습니다. 어서빨리 C++에서도 객체지향을 즐길(?) 수 있게 되면 좋겠네요! 한줄한줄 끝없는 구글링은 싫어욧!","categories":[{"name":"programming","slug":"programming","permalink":"https://hjjjong0811.github.io/categories/programming/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hjjjong0811.github.io/tags/C/"},{"name":"가상함수","slug":"가상함수","permalink":"https://hjjjong0811.github.io/tags/가상함수/"}]},{"title":"C++ Template란?","slug":"programming/180907_CPPtemplate","date":"2018-09-07T10:36:43.000Z","updated":"2018-09-08T12:47:52.444Z","comments":true,"path":"2018/09/07/programming/180907_CPPtemplate/","link":"","permalink":"https://hjjjong0811.github.io/2018/09/07/programming/180907_CPPtemplate/","excerpt":"","text":"C++ Template 은 알 것 같으면서도 모르겠다. 다시 한번 정리를 한번하고가야 써야할 때 제대로 활용할 수 있을 것같다. C# Generic혹시 C#을 하신 분이라면 generic에 대해 한번은 들어봤을 것이다. 나도 딱히 즐겨사용하던 건 아니지만.. 예를 들면 list같은 자료구조를 구현한 클래스에 generic이 적용된 경우 int, float 같은 타입에 상관없이 사용할 수 있다. generic을 이용해서 자료구조같은 걸 직접 구현하지 않았더라도 다음과 같은 걸 사용해본 적은 있지 않을까? 12&gt; List&lt;Interger&gt; myList = new List&lt;Integer&gt;();&gt; C# generic / C++ templateC++의 Template는 C#의 Generic과 비슷하지만 몇가지 차이점이 있다. msdn 문서에서는 다음과 같이 주요 차이점을 설명하고 있다. C# 제네릭은 C++ 템플릿과 동일한 수준의 유연성을 제공하지 않습니다. 예를 들어 C# 제네릭 클래스에서 산술 연산자는 호출할 수 없지만 사용자 정의 연산자는 호출할 수 있습니다. C#에서는 template C&lt;int i&gt; {} 같은 비형식 템플릿 매개 변수를 허용하지 않습니다. C#은 명시적 특수화 즉, 특정 형식에 대한 템플릿의 사용자 지정 구현을 지원하지 않습니다. C#은 부분 특수화 즉, 형식 인수의 하위 집합에 대한 사용자 지정 구현을 지원하지 않습니다. C#에서는 형식 매개 변수를 제네릭 형식에 대한 기본 클래스로 사용할 수 없습니다. C#에서는 형식 매개 변수가 기본 형식을 사용할 수 없습니다. C#에서 제네릭 형식 매개 변수 자체는 제네릭이 될 수 없지만 생성된 형식은 제네릭으로 사용할 수 있습니다. C++에서는 템플릿 매개 변수를 허용합니다. C++에서는 템플릿의 일부 형식 매개 변수에 적합하지 않아 형식 매개 변수로 사용되는 특정 형식을 확인하는 코드를 허용합니다. C#에서는 제약 조건을 충족하는 모든 형식에서 작동하는 방식으로 작성할 코드가 클래스에 필요합니다. 예를 들어 C++에서는 산술 연산자 + 및 -를 사용하는 함수를 형식 매개 변수의 개체에서 작성하여 이러한 연산자를 지원하지 않는 형식으로 템플릿을 인스턴스화할 때 오류를 생성할 수 있습니다. C#에서는 이를 허용하지 않습니다. 허용되는 유일한 언어 구문은 제약 조건에서 추론할 수 있는 구문입니다. 차이점만 보았을 때는 C# Generic이 C++ Template의 간소화버전같은 느낌이다. Template 이 복잡한만큼 잘 용하면 할 수 있는 일이 많아보인다. 또한 구현수준에서의 차이점을 이렇게 설명하고 있다. 구현 수준에서 주요 차이점은 런타임에 C# 제네릭 형식 대체가 수행되어 인스턴스화된 개체에 대해 제네릭 형식 정보가 유지된다는 점입니다. Template는 컴파일 시점에 타입별로 코드가 생성된다. 반면에 Generic은 런타임에 타입별로 특수화된 제네릭 형식을 만든다고 한다. template는 컴파일 시점에 만드니까 컴파일 시간과 용량이 커지는 대신 속도가 빠를 것으로 예상되는데.. Template 란그래서 Template 란 어떤 것일까? 사전적 의미로는 형판을 뜻한다. 무언가(구체적인 타입)를 만들기 위한 형판이라고 보면 되겠다. 만약 List 자료구조를 만드려는데 int, float, 각종 사용자 타입별로 list를 각각 구현하면 어떨까? List를 이용해야하는 타입별로 전부 코드를 작성해야할 것이다. 이용할 타입이 추가되는 경우 또 그에맞는 NewTypeList 클래스를 만들고.. 만약 메소드 기능을 바꾸려한다면? 모든 클래스를 수정해야하는 끔찍한 일이 생긴다. Temlate 를 이용하면 여러 타입에서 작동할 수 있는 클래스나 함수를 구현할 수 있다. C++ 에서 Template라는 기능을 지원하는 것에 감사하며 구체적으로 어디에 적용할 수 있는지를 알아보자! Template의 종류Template의 종류로는 함수 템플릿, 클래스 템플릿 두 가지가 있다. C++14부터는 세번째 템플릿으로 변수 템플릿이 있다. Wiki) 클래스 템플릿 함수 템플릿 변수 템플릿(C++ 14 ~) 클래스 템플릿12345template &lt;typename T&gt;class List&#123;public: void push_back(T value);&#125;; 클래스에 템플릿을 적용한 것이다. 그런데 템플릿을 적용한 클래스가 모든 타입에 대해서 제대로 작동할까? 만약 특정 타입에 대해서는 전후에 해야할 작업이 있다면 어떻게 하면 좋을까 그런 경우에는 특수화를 이용해서 문제를 해결할 수 있다 명시적특수화1234567891011121314151617template &lt;class T&gt; class Formatter&#123; T* m_t;public: Formatter(T* t) : m_t(t)&#123;&#125; void print()&#123; cout &lt;&lt; *m_t &lt;&lt; endl; &#125;&#125;;template&lt;&gt; class Formatter&lt;char*&gt;&#123; char** m_t;public: formatter(char** t) : m_t(t)&#123;&#125; void print()&#123; cout &lt;&lt; \"Char value: \" &lt;&lt; **m_t &lt;&lt; endl; &#125;&#125;; 클래스에서 이용하는 타입매개변수 전체에 대해 특수화할 수 있다. 위 예제에서 char* 의 경우는 특수화 된 클래스를 이용한다. 마치 클래스를 오버로딩하는 듯 하다. 부분특수화123456789template &lt;typename T1, typename T2&gt;class MyExamClass&#123; ...&#125;;template &lt;typename T1&gt;class MyExamClass&lt;T*, int&gt;&#123; ...&#125;; 변수 일부에 대해 부분적으로 특수화할 수 있다. 함수 템플릿1234template &lt;typename T&gt;void print(T value)&#123; ...&#125; 템플릿은 함수에도 적용될 수 있다. 템플릿 오버로딩1234567template &lt;typename T&gt;void print(T value);void print(int value);template &lt;typename T1, T2&gt;void print(T1 val1, T2 val2); 다른 함수들처럼 오버로딩할 수 있다. 장단점장점 각 타입별로 같은 기능을 지원하는 클래스를 따로 만들 필요가 없다! (야호) 실제로 사용한 타입에 대해서만 코드가 생성된다 단점 컴파일 시간이 길어진다 용량이 커질 수 있다 ETCtypename? class?보통은 어느 것을 쓰던 상관없지만 특수한 경우가 있다고 한다. 자세한 내용은 여기 템플릿 메타프로그래밍템플릿 메타프로그래밍(Template Metaprogramming)은 템플릿을 이용한 프로그래밍 기법으로, 컴파일러에게 프로그램 코드를 생성하도록 하는 방식이다.Wiki Template는 컴파일 시점에 코드가 생성된다. 따라서 런타임이 아닌 컴파일 시점으로 작업을 옮길 수 있어 잘만 이용하면 효율적이다. 물론 디버깅도 어렵고 잘못하면 안좋을 것같다.. 12345678910template &lt;int N&gt;struct Factorial &#123; enum &#123;value = N * Factorial&lt;N-1&gt;::value&#125;;&#125;;template&lt;&gt;sturct Factorial&lt;0&gt;&#123; enum &#123;value = 1&#125;;&#125;;//Factorial&lt;4&gt;::value == 24//Factorial&lt;0&gt;::value == 1 팩토리얼이 예제로 많이 나오는데, 템플릿의 경우 컴파일 때 타입별로 코드를 생성하므로, 필요한 팩토리얼 값만 구할 수 있다. 다만 Factorial&lt;X&gt;::value 에서 X는 컴파일 시점에 알 수 있는 상수 값이어야 한다.","categories":[{"name":"programming","slug":"programming","permalink":"https://hjjjong0811.github.io/categories/programming/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hjjjong0811.github.io/tags/C/"},{"name":"template","slug":"template","permalink":"https://hjjjong0811.github.io/tags/template/"}]},{"title":"깃허브 블로그 시작!","slug":"daily/180906_블로그시작","date":"2018-09-05T15:43:00.000Z","updated":"2018-09-08T11:02:13.925Z","comments":true,"path":"2018/09/06/daily/180906_블로그시작/","link":"","permalink":"https://hjjjong0811.github.io/2018/09/06/daily/180906_블로그시작/","excerpt":"","text":"네이버 블로그를 쓰다가 꾸미는데 답답함을 느껴서 이사왔다!블로그 처음 시작할때는 내용이 좀 대충이더라도 꾸준히 포스팅을 하자고 생각했는데, 공부만 아니라 포스팅하는데도 시간이 걸리다보니 계속 미루게 됐다 일하면서 보고 느낀건데 스스로 어디를 어떻게 모르는지 아는게 굉장히 중요한 것 같다그래서 요즘은 프로그래밍하다 생각할 게 있을 때면 메모장에 내가 어떻게 생각을 해나가는지 적어보고 있다! 머리 속에서 날라가게 안놔두고 적어보니까 부족한 부분이 이전보다 잘 보여서 좋다 또 한번에 정리된 내용을 적으려 하면 참 부담이 많이 된다.중고등학교때 노트정리를 하면 꼭 단원은 대괄호, 주제는 1. , 상세 내용은 소괄호.. 나름의 규칙을 정해서 반듯하게 정리하려 노력했었는데 시간이 엄청 걸렸다. 그래서 형식을 다 없애고 싶어서 공책을 전부 찢어서 낱장으로 썼다. 얼마든지 수정할 수 있다는 안도감?을 주고 싶었다. 훨씬 효율이 나아졌다. 그 뒤로 마음속에 적당히, 대충, 빨리 세 단어를 새겼다. 그래서 이런저런 이유로 블로그 이사온 김에 이번 블로그는 좀더 빠르게 적어보려고 한다! 적어놓고 다시 보고, 다듬어나가다보면 언젠가는 한번에 좋은 포스팅을 할 수 있겠지! Written with StackEdit.","categories":[{"name":"daily","slug":"daily","permalink":"https://hjjjong0811.github.io/categories/daily/"}],"tags":[]},{"title":"Visual Studio로 Linux 원격 개발하기(Ubuntu 설치부터 SSH 서버접속까지)","slug":"information/180721_VisualStudio_Linux_원격개발","date":"2018-07-21T12:47:00.000Z","updated":"2018-09-08T18:59:59.957Z","comments":true,"path":"2018/07/21/information/180721_VisualStudio_Linux_원격개발/","link":"","permalink":"https://hjjjong0811.github.io/2018/07/21/information/180721_VisualStudio_Linux_원격개발/","excerpt":"","text":"Update History 2018.09.09 수정 열혈강의 TCP/IP 책을 공부하려는데 리눅스 얘기가 좀 많이 나왔다. 책이 아니더라도 서버로 Linux는 많이 쓰이니까 알아두면 좋을 것 같아서 Linux 환경을 세팅하고 공부하고 싶었따! 원래 가지고 있던 노트북이 두개였는데, 하나는 주로 쓰는 Windows10 깔린 게이밍 노트북이고, 또 하나는 옛날에 친철오빠가 안쓰는걸 줘서 문서용으로 고맙게 쓰다가 지금은 방치해둔 노트북이다. 방치해뒀던 옛날 노트북에 Ubuntu Desktop을 깔았다. 정말 아무것도 모르는 상태에서 시작하고, 아무것도 모르는 채로 포스팅하고 있으니 읽을 때 주의바란다..ㅠㅠ 준비물 컴퓨터 2대(Window, Linux 기반 OS) Ubuntu 설치Ubuntu Download 및 부팅 USB 만들기설치는 Ubuntu 사이트 에 가면 USB 부팅디스크 만드는 법이랑 설치파일이 있다. iso 파일을 받고, How to write a USB 링크에 들어가면 Rufus[^1]를 이용해서 부팅용 USB를 만들 수 있다. 링크에 자세히 나와있다. Alternative downloads 에 들어가면 이전 버전의 Ubuntu를 설치할 수도 있다. Ubuntu 설치BIOS 설정에서 USB 부팅으로 변경부팅용으로 만든 USB를 노트북에 꼽고, 컴퓨터를 키면서 F2(F12, F10, DEL… 키 일수도 있다. 메인보드 제조사마다 다름)를 누르면 BIOS 설정창에 들어온다. 거기서 USB로 부팅되게끔 설정을 바꿔준다. BIOS 설정창도 제조사마다 또 다르다. Ubuntu 설치부팅을 USB로 바꾼 후에 재부팅하면 Ubuntu 설치가 진행된다. 블로그에 올릴생각이 아니었어서 사진은 없당…. 설치 중에 입력한 사용자 이름이랑 비밀번호로 원격 접속을 할거니까 적당하게 잘 정해주도록 하자. Windows만 썼는데 다른거 까니까 되게 신기하고 막 기분이상하다ㅠㅠㅠ감동? 언어 설정 일단 언어 설정부터했다 영어가 입력이 안됐었다ㅠㅠ.. 시스템 설정-&gt;텍스트입력창 을 누르면 입력 소스를 추가할 수 있다. +버튼을 눌러서 영어(미국)을 추가하자! 만약 언어가 설치안되었다면 시스템설정-&gt;언어지원에 가면 설치할 수 있다 SSH 서버 열기이제 터미널 창을 열어야지!!! 했는데 난 윈도우밖에 안써봤다.. 어떻게 열지? 할땐 구글링… Ctrl + Alt + T 를 누르면 열리니까 참고하자 vim 에디터 설치그럼이제 SSH 서버를 열건뎅 그전에 vim 에디터[^2]를 설치했다. 설치 방법은 Ubuntu에 vi(vim)에디터 설치 를 참고했다. 세상엔 친절한 사람이 정말 많다..감사합니다 SSH(Secure Shell) 란?SSH 서버를 설치하기 전에 잠시 ssh 가 뭔지 집고 가자. 시큐어 셸(Secure Shell, SSH)은 네트워크상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 가리킨다. 출처 Wiki 텔넷과 마찬가지로 원격 접속을 위한 프로토콜이며, 텔넷의 보안상 문제를 해결하기 위해 나왔으다. 텔넷은 23번, SSH는 22번 포트를 이용한다. SSH Server 설치 및 설정SSH 설치와 설정에는 SSH(Secure SHell) 설치와 사용법(Ubuntu) 를 참고했다. SSH Server 설치먼저 ssh Server를 설치하기 위해서 터미널에 아래 명령어를 입력했다 1sudo apt-get install openssh-server g++ gdb gdbserver 설정그리고나서 설정파일을 수정했다. 아래 명령어를 치면 설정파일을 열 수 있다. 1sudo vim /etc/ssh/sshd_config vi 에디터에서 i 를 누르면 수정이 가능하고, esc를 누르고 :wq! 를 치면 저장하고 나갈 수 있다. Port 는 22로 되어있을건데, 굳이 바꾸지 않아도 된다. 나는 심심하니까 바꿨다. PasswordAuthentication 을 yes로 해야 사용자 비밀번호로 들어올 수 있다. 보안 문제로 비밀번호로 들어오는 것보다는 공개키 인증방식을 권장한다고 한다. 하지만 나는 공유기 내부에서만 쓸 것이고, ssh server를 그리 자주 열어두지 않을 것이므로 편하게 비밀번호로 했다. 설정 수정이 끝났으면 ESC + :wq! 로 나가자. SSH Server 열기ssh server 설치와 설정이 끝난 후에 터미널 창에서 명령어를 입력하면 서버를 열 수 있다. 서버를 여는 데는 아래 명령어들이 사용된다. 차례로 입력해주자. 1sudo service ssh restart 서비스 재시작 12sudo ufw enablesudo ufw allow (설정한 포트번호) 방화벽을 활성화하고, 포트를 열어준다 명령어가 헷갈릴 때는 sudo ufw help 였던가?? 아무튼 언제나 help 를 대충 붙여보면 명령어들을 알려준다. 잘 까먹는 편이라 명령어로 해야할 때는 help를 참 자주쓴다.. IP 확인터미널에 접속하기 위해서는 IP주소가 필요한데, Ubuntu 터미널 창에 ip addr을 입력해서 접속할 IP를 확인하자. 127.0.0.1은 루프백이고 좀 아래쪽에 IPv4 주소가 나올거다. Visual Studio SSH 개발Visual Studio 원격 접속 방법이나 VS로 디버깅하는 법은 VS2017을 사용하여 리눅스 프로그래밍하기 를 참고했다. 디버깅하는 법이나 라즈베리파이 관련해서 자세히알려주시니까 한번 들어가보면 조켓다! 감사합니다 ㅎㅎㅎ Linux 개발환경 설치그럼이제 Windows 컴퓨터로 돌아와서 열어놓은 SSH 서버로 원격개발을 해야하는데 먼저 Visual Studio 2017 Installer 를 열어서 Linux 개발환경을 설치한다 원격 시스템 연결그리고나서 Visual Studio를 열어서 디버그-&gt;옵션-&gt;플랫폼간-&gt;연결관리자 에 들어간다. 거기서 추가를 누르면 원격 시스템에 연결할 수 있다. IP, PORT, 그리고 Ubuntu OS를 설치할때 등록한 사용자(싫으면 다른 사용자..)이름이랑 암호를 넣어준다 Linux 프로젝트 생성 새프로젝트를 만들때 플랫폼간-&gt;Linux로 생성하면 Linux 코드를 짤수있다. 빌드한 코드는 Ubuntu 노트북에 쏚쏚 들어오는데 그 경로는 프로젝트 속성에 나와있다. 기본적으로 홈/projects/(프로젝트이름) 으로 생긴다 아! 실행했을때 printf 한게 안보여두 당황하지말고 Visual Studio의 디버그-&gt;Linux콘솔을 열어 확인하자 헤헤 이러케 설정을 마치고 네트워크프로그래밍 공부하는데 신기하당! 컴두개켜놓고 실행해보니까 쿨러 도느라 덥고..폭염이고 여기서짠 코드가 저기서 돌아가고 해서 신기하다! 포스팅이 처음부터 끝까지적느라 내용이 많이 부족하므로 링크 들어가서 다른분들 글을 좀더 참고하기를 추천드린다 책따라서 공부좀 하다가 어느정도 좋아지면 윈도우랑 Linux 둘다 돌아가는 코드를 짜볼 예정이다! [^1]: 부팅 가능한 USB를 만들어주는 Windows 용 오픈소스 프로그램[^2]: vi 호환 텍스트 편집기. 줄번호, 문법 강조, 유니코드를 비롯한 다국어 지원 등의 기능을 갖춤.","categories":[{"name":"information","slug":"information","permalink":"https://hjjjong0811.github.io/categories/information/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"https://hjjjong0811.github.io/tags/SSH/"},{"name":"Linux","slug":"Linux","permalink":"https://hjjjong0811.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hjjjong0811.github.io/tags/Ubuntu/"},{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://hjjjong0811.github.io/tags/VisualStudio/"}]},{"title":"화면 낙서 프로그램 ScreenSketch!","slug":"download/180429_화면낙서","date":"2018-04-28T18:17:00.000Z","updated":"2018-09-08T13:04:32.403Z","comments":true,"path":"2018/04/29/download/180429_화면낙서/","link":"","permalink":"https://hjjjong0811.github.io/2018/04/29/download/180429_화면낙서/","excerpt":"","text":"Update History 2018.09.08 수정 Windows : ScreenSketch 1.0.0 Download 간단하게 밑줄정도 그을 수 있는 프로그램을 찾다가 만들었습니다. 프로그램 창 안에서 밑줄을 그을 수 있고, 캡쳐 후 낙서하는 것이 아니라 투명창이기 때문에 배경? 화면?이 바뀌어야 하는 경우 사용하기 좋습니다 기능 목록 낙서 창크기 조절 색, 브러쉬 사이즈 조절 캡쳐(F12) 기능은 불필요한거 빼고 최대한 빠르게 만들었습니다. 간단한 밑줄 정도로 생각하고 만들어서 포커스를 잃는 경우 내용이 지워질수 있어요. 그림을 그리거나 많은양의 필기를 권하지 않습니다.. C# WinForm 이용해서 만들었고, 테스트 환경은 Windows 64bit 입니다","categories":[{"name":"download","slug":"download","permalink":"https://hjjjong0811.github.io/categories/download/"}],"tags":[{"name":"프로그램","slug":"프로그램","permalink":"https://hjjjong0811.github.io/tags/프로그램/"},{"name":"화면낙서","slug":"화면낙서","permalink":"https://hjjjong0811.github.io/tags/화면낙서/"}]},{"title":"예전에 만든 지우개도장들","slug":"hobby/170818_지우개도장","date":"2017-08-17T17:01:00.000Z","updated":"2018-09-08T12:41:34.863Z","comments":true,"path":"2017/08/18/hobby/170818_지우개도장/","link":"","permalink":"https://hjjjong0811.github.io/2017/08/18/hobby/170818_지우개도장/","excerpt":"","text":"예전에 팠던 지우개도장들!전부 친구들 줌ㅎㅎㅎ노가다도 심하고 눈도 아프지만 재미있었다!다시 하라고 한다면 손떨려서 잘 못할것같다","categories":[{"name":"hobby","slug":"hobby","permalink":"https://hjjjong0811.github.io/categories/hobby/"}],"tags":[{"name":"도장","slug":"도장","permalink":"https://hjjjong0811.github.io/tags/도장/"}]},{"title":"크롬 검색이 강제로 야후로 돼요","slug":"information/170721_크롬검색야후","date":"2017-07-21T04:32:00.000Z","updated":"2018-09-08T12:47:39.217Z","comments":true,"path":"2017/07/21/information/170721_크롬검색야후/","link":"","permalink":"https://hjjjong0811.github.io/2017/07/21/information/170721_크롬검색야후/","excerpt":"","text":"Update History 2018.09.08 수정 노트북을 사고 인터넷을 여기저기 들어가다보니 어느 순간부터 크롬 시작페이지가 구글이 아닌 다른 곳으로 가지고, 주소창에 검색을 하면 구글주소가 뜨는 듯 하더니 야후로 검색이 되네요. 뭐때문인가 찾아봤더니 크롬 확장프로그램에 못보던게 깔려있더라구요 Plugins button 이라는 확장프로그램이었습니다. 애드웨어인가봐요 새 노트북인데.. 지금은 지워서 없는데요, 구글 확장프로그램 페이지에서 삭제를 하려고해도 엔터프라이즈 정책에 의해 설치됨 이라고만 뜨고 삭제버튼이 안먹더라구요 제가 지운 방법 포스팅합니다 방법1 폴더에서 삭제 먼저 chrome://extensions/ 에 들어가서 못보던 확장프로그램이 있는지 확인합니다 그리고 개발자 모드에 체크합니다 개발자모드에 체크하면 ID가 뜨는데요 이 ID를 확인해줍니다 확인 후에 C:\\Users\\(계정)\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions 에 들어가보면 ID로된 폴더들이 있을건데요 만약 폴더가 보이지 않는다면 폴더 보기 옵션에서 숨긴항목 표시를 체크해주세요 C:\\Windows\\System32\\GroupPolicy\\Machine\\Registry.pol 파일을 지워주세요 이 파일을 지우고나서 chrome://policy/에 들어가보면 지워진걸 확인할 수 있습니다 방법2 레지스트리 편집기에서 삭제만약 확장 프로그램이 이 방법으로 삭제되지 않는 경우 레지스트리 편집기에서 삭제하실 수도 있습니다. 레지스트리 편집기 실행 실행(Win + R) -&gt; regedit HKEY_LOCAL_MACHINE - SOFTWARE - Policies - Google - Chrome - ExtensionInstallForcelist 삭제 이후에 크롬을 다시시작했더니 야후가 아니라 구글로 제대로 되었습니다 저는 이방법으로 해결했어요 잘못된 것이 있다면 댓글 달아주시기 바랍니다!","categories":[{"name":"information","slug":"information","permalink":"https://hjjjong0811.github.io/categories/information/"}],"tags":[]}]}