{"meta":{"title":"JJONGLOG","subtitle":"PROGRAMMING&PAINTING","description":null,"author":"jjong","url":"https://hjjjong0811.github.io"},"pages":[{"title":"Archives","date":"2018-09-05T07:44:05.169Z","updated":"2018-09-05T07:44:05.169Z","comments":true,"path":"archives.html","permalink":"https://hjjjong0811.github.io/archives.html","excerpt":"","text":""},{"title":"About","date":"2018-09-05T10:31:52.082Z","updated":"2018-09-05T10:31:52.082Z","comments":true,"path":"about.html","permalink":"https://hjjjong0811.github.io/about.html","excerpt":"","text":"JJONGLOG, PROGRAMMING &amp; PAINTING 프로그래밍을 공부하다보면 블로거분들의 도움을 많이 받는다. 알고 있는 지식들을 정리해서 올려주시고, 여쭤보면 댓글도 달아주신다. 도움을 받으며 나도 나중에 지식이 많아지면 내가 알고 있는 것들을 공유해야지 라고 생각해왔는데 대학 4학년이 되어서도 늘은 거라고는 구글링 뿐! 그래서 그냥 공부 목적의 블로그를 시작합니다! 공부 외에도 일상과 취미 관련한 내용을 올릴 예정입니다. 그림그리는 것과 뭔가 만드는 걸 좋아합니다! 만약 보시던 중 잘못된 내용이 있다면 덧글로 자유롭게 피드백주시면 감사하겠습니다"},{"title":"All tags","date":"2018-09-04T18:26:09.932Z","updated":"2018-09-04T18:26:09.932Z","comments":true,"path":"tags/index.html","permalink":"https://hjjjong0811.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ Template란?","slug":"180907_CPPtemplate","date":"2018-09-07T10:36:43.000Z","updated":"2018-09-07T11:02:14.894Z","comments":true,"path":"2018/09/07/180907_CPPtemplate/","link":"","permalink":"https://hjjjong0811.github.io/2018/09/07/180907_CPPtemplate/","excerpt":"","text":"C++ Template 은 알 것 같으면서도 모르겠다. 다시 한번 정리를 한번하고가야 써야할 때 제대로 활용할 수 있을 것같다. C# Generic혹시 C#을 하신 분이라면 generic에 대해 한번은 들어봤을 것이다. 나도 딱히 즐겨사용하던 건 아니지만.. 예를 들면 list같은 자료구조를 구현한 클래스에 generic이 적용된 경우 int, float 같은 타입에 상관없이 사용할 수 있다. generic을 이용해서 자료구조같은 걸 직접 구현하지 않았더라도 다음과 같은 걸 사용해본 적은 있지 않을까? 12&gt; List&lt;Interger&gt; myList = new List&lt;Integer&gt;();&gt; C# generic / C++ templateC++의 Template는 C#의 Generic과 비슷하지만 몇가지 차이점이 있다. msdn 문서에서는 다음과 같이 주요 차이점을 설명하고 있다. C# 제네릭은 C++ 템플릿과 동일한 수준의 유연성을 제공하지 않습니다. 예를 들어 C# 제네릭 클래스에서 산술 연산자는 호출할 수 없지만 사용자 정의 연산자는 호출할 수 있습니다. C#에서는 template C&lt;int i&gt; {} 같은 비형식 템플릿 매개 변수를 허용하지 않습니다. C#은 명시적 특수화 즉, 특정 형식에 대한 템플릿의 사용자 지정 구현을 지원하지 않습니다. C#은 부분 특수화 즉, 형식 인수의 하위 집합에 대한 사용자 지정 구현을 지원하지 않습니다. C#에서는 형식 매개 변수를 제네릭 형식에 대한 기본 클래스로 사용할 수 없습니다. C#에서는 형식 매개 변수가 기본 형식을 사용할 수 없습니다. C#에서 제네릭 형식 매개 변수 자체는 제네릭이 될 수 없지만 생성된 형식은 제네릭으로 사용할 수 있습니다. C++에서는 템플릿 매개 변수를 허용합니다. C++에서는 템플릿의 일부 형식 매개 변수에 적합하지 않아 형식 매개 변수로 사용되는 특정 형식을 확인하는 코드를 허용합니다. C#에서는 제약 조건을 충족하는 모든 형식에서 작동하는 방식으로 작성할 코드가 클래스에 필요합니다. 예를 들어 C++에서는 산술 연산자 + 및 -를 사용하는 함수를 형식 매개 변수의 개체에서 작성하여 이러한 연산자를 지원하지 않는 형식으로 템플릿을 인스턴스화할 때 오류를 생성할 수 있습니다. C#에서는 이를 허용하지 않습니다. 허용되는 유일한 언어 구문은 제약 조건에서 추론할 수 있는 구문입니다. 차이점만 보았을 때는 C# Generic이 C++ Template의 간소화버전같은 느낌이다. Template 이 복잡한만큼 잘 용하면 할 수 있는 일이 많아보인다. 또한 구현수준에서의 차이점을 이렇게 설명하고 있다. 구현 수준에서 주요 차이점은 런타임에 C# 제네릭 형식 대체가 수행되어 인스턴스화된 개체에 대해 제네릭 형식 정보가 유지된다는 점입니다. Template는 컴파일 시점에 타입별로 코드가 생성된다. 반면에 Generic은 런타임에 타입별로 특수화된 제네릭 형식을 만든다고 한다. template는 컴파일 시점에 만드니까 컴파일 시간과 용량이 커지는 대신 속도가 빠를 것으로 예상되는데.. Template 란그래서 Template 란 어떤 것일까? 사전적 의미로는 형판을 뜻한다. 무언가(구체적인 타입)를 만들기 위한 형판이라고 보면 되겠다. 만약 List 자료구조를 만드려는데 int, float, 각종 사용자 타입별로 list를 각각 구현하면 어떨까? List를 이용해야하는 타입별로 전부 코드를 작성해야할 것이다. 이용할 타입이 추가되는 경우 또 그에맞는 NewTypeList 클래스를 만들고.. 만약 메소드 기능을 바꾸려한다면? 모든 클래스를 수정해야하는 끔찍한 일이 생긴다. Temlate 를 이용하면 여러 타입에서 작동할 수 있는 클래스나 함수를 구현할 수 있다. C++ 에서 Template라는 기능을 지원하는 것에 감사하며 구체적으로 어디에 적용할 수 있는지를 알아보자! Template의 종류Template의 종류로는 함수 템플릿, 클래스 템플릿 두 가지가 있다. C++14부터는 세번째 템플릿으로 변수 템플릿이 있다. Wiki) 클래스 템플릿 함수 템플릿 변수 템플릿(C++ 14 ~) 클래스 템플릿12345template &lt;typename T&gt;class List&#123;public: void push_back(T value);&#125;; 클래스에 템플릿을 적용한 것이다. 그런데 템플릿을 적용한 클래스가 모든 타입에 대해서 제대로 작동할까? 만약 특정 타입에 대해서는 전후에 해야할 작업이 있다면 어떻게 하면 좋을까 그런 경우에는 특수화를 이용해서 문제를 해결할 수 있다 명시적특수화1234567891011121314151617template &lt;class T&gt; class Formatter&#123; T* m_t;public: Formatter(T* t) : m_t(t)&#123;&#125; void print()&#123; cout &lt;&lt; *m_t &lt;&lt; endl; &#125;&#125;;template&lt;&gt; class Formatter&lt;char*&gt;&#123; char** m_t;public: formatter(char** t) : m_t(t)&#123;&#125; void print()&#123; cout &lt;&lt; \"Char value: \" &lt;&lt; **m_t &lt;&lt; endl; &#125;&#125;; 클래스에서 이용하는 타입매개변수 전체에 대해 특수화할 수 있다. 위 예제에서 char* 의 경우는 특수화 된 클래스를 이용한다. 마치 클래스를 오버로딩하는 듯 하다. 부분특수화123456789template &lt;typename T1, typename T2&gt;class MyExamClass&#123; ...&#125;;template &lt;typename T1&gt;class MyExamClass&lt;T*, int&gt;&#123; ...&#125;; 변수 일부에 대해 부분적으로 특수화할 수 있다. 함수 템플릿1234template &lt;typename T&gt;void print(T value)&#123; ...&#125; 템플릿은 함수에도 적용될 수 있다. 템플릿 오버로딩1234567template &lt;typename T&gt;void print(T value);void print(int value);template &lt;typename T1, T2&gt;void print(T1 val1, T2 val2); 다른 함수들처럼 오버로딩할 수 있다. 장단점장점 각 타입별로 같은 기능을 지원하는 클래스를 따로 만들 필요가 없다! (야호) 실제로 사용한 타입에 대해서만 코드가 생성된다 단점 컴파일 시간이 길어진다 용량이 커질 수 있다 ETCtypename? class?보통은 어느 것을 쓰던 상관없지만 특수한 경우가 있다고 한다. 자세한 내용은 여기 템플릿 메타프로그래밍템플릿 메타프로그래밍(Template Metaprogramming)은 템플릿을 이용한 프로그래밍 기법으로, 컴파일러에게 프로그램 코드를 생성하도록 하는 방식이다.Wiki Template는 컴파일 시점에 코드가 생성된다. 따라서 런타임이 아닌 컴파일 시점으로 작업을 옮길 수 있어 잘만 이용하면 효율적이다. 물론 디버깅도 어렵고 잘못하면 안좋을 것같다.. 12345678910template &lt;int N&gt;struct Factorial &#123; enum &#123;value = N * Factorial&lt;N-1&gt;::value&#125;;&#125;;template&lt;&gt;sturct Factorial&lt;0&gt;&#123; enum &#123;value = 1&#125;;&#125;;//Factorial&lt;4&gt;::value == 24//Factorial&lt;0&gt;::value == 1 팩토리얼이 예제로 많이 나오는데, 템플릿의 경우 컴파일 때 타입별로 코드를 생성하므로, 필요한 팩토리얼 값만 구할 수 있다. 다만 Factorial::value 에서 X는 컴파일 시점에 알 수 있는 상수 값이어야 한다.","categories":[{"name":"programming","slug":"programming","permalink":"https://hjjjong0811.github.io/categories/programming/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://hjjjong0811.github.io/tags/C/"},{"name":"template","slug":"template","permalink":"https://hjjjong0811.github.io/tags/template/"}]},{"title":"Dummy2","slug":"Dummy2","date":"2018-09-06T12:23:37.000Z","updated":"2018-09-06T17:05:24.882Z","comments":true,"path":"2018/09/06/Dummy2/","link":"","permalink":"https://hjjjong0811.github.io/2018/09/06/Dummy2/","excerpt":"","text":"Test 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;namespace Test&#123; enum TestEnum&#123; COOL, BANANABOAT &#125; class TestClass : public Mom&#123; public: static TestClass getInstance()&#123; return instance; &#125; virtual void test(int param) = 0; private: int _mNum; //Dummy Member Var static const int DDDDD = 343; &#125;&#125;int main()&#123; int num = 0; TestClass t; for(int i=0; i&lt; 10; ++i)&#123; num += i; &#125; return 0;&#125;","categories":[{"name":"hobby","slug":"hobby","permalink":"https://hjjjong0811.github.io/categories/hobby/"}],"tags":[{"name":"DummyTag1","slug":"DummyTag1","permalink":"https://hjjjong0811.github.io/tags/DummyTag1/"}]},{"title":"Dummy3","slug":"Dummy3","date":"2018-09-06T12:23:37.000Z","updated":"2018-09-06T17:05:16.177Z","comments":true,"path":"2018/09/06/Dummy3/","link":"","permalink":"https://hjjjong0811.github.io/2018/09/06/Dummy3/","excerpt":"","text":"Test","categories":[{"name":"information","slug":"information","permalink":"https://hjjjong0811.github.io/categories/information/"}],"tags":[{"name":"DummyTag1","slug":"DummyTag1","permalink":"https://hjjjong0811.github.io/tags/DummyTag1/"}]},{"title":"Dummy","slug":"Dummy5","date":"2018-09-06T12:23:37.000Z","updated":"2018-09-06T17:05:50.164Z","comments":true,"path":"2018/09/06/Dummy5/","link":"","permalink":"https://hjjjong0811.github.io/2018/09/06/Dummy5/","excerpt":"","text":"Test","categories":[{"name":"download","slug":"download","permalink":"https://hjjjong0811.github.io/categories/download/"}],"tags":[{"name":"DummyTag1","slug":"DummyTag1","permalink":"https://hjjjong0811.github.io/tags/DummyTag1/"}]},{"title":"깃허브 블로그 시작!","slug":"180906_블로그시작","date":"2018-09-05T15:43:00.000Z","updated":"2018-09-06T15:05:02.771Z","comments":true,"path":"2018/09/06/180906_블로그시작/","link":"","permalink":"https://hjjjong0811.github.io/2018/09/06/180906_블로그시작/","excerpt":"","text":"네이버 블로그를 쓰다가 꾸미는데 답답함을 느껴서 이사왔다!블로그 처음 시작할때는 내용이 좀 대충이더라도 꾸준히 포스팅을 하자고 생각했는데, 공부만 아니라 포스팅하는데도 시간이 걸리다보니 계속 미루게 됐다 일하면서 보고 느낀건데 스스로 어디를 어떻게 모르는지 아는게 굉장히 중요한 것 같다그래서 요즘은 프로그래밍하다 생각할 게 있을 때면 메모장에 내가 어떻게 생각을 해나가는지 적어보고 있다! 머리 속에서 날라가게 안놔두고 적어보니까 부족한 부분이 이전보다 잘 보여서 좋다 또 한번에 정리된 내용을 적으려 하면 참 부담이 많이 된다.중고등학교때 노트정리를 하면 꼭 단원은 대괄호, 주제는 1. , 상세 내용은 소괄호.. 나름의 규칙을 정해서 반듯하게 정리하려 노력했었는데 시간이 엄청 걸렸다. 그래서 형식을 다 없애고 싶어서 공책을 전부 찢어서 낱장으로 썼다. 얼마든지 수정할 수 있다는 안도감?을 주고 싶었다. 훨씬 효율이 나아졌다. 그 뒤로 마음속에 적당히, 대충, 빨리 세 단어를 새겼다. 그래서 이런저런 이유로 블로그 이사온 김에 이번 블로그는 좀더 빠르게 적어보려고 한다! 적어놓고 다시 보고, 다듬어나가다보면 언젠가는 한번에 좋은 포스팅을 할 수 있겠지! Written with StackEdit.","categories":[{"name":"daily","slug":"daily","permalink":"https://hjjjong0811.github.io/categories/daily/"}],"tags":[]}]}